<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cyber Block</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            overflow: hidden; /* Prevent scrollbars */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            user-select: none;
            touch-action: none; /* Critical for mobile game controls */
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(to bottom, #0f0c29, #302b63, #24243e);
            overflow: hidden;
        }

        canvas {
            display: block;
            /* This ensures the game scales up but keeps aspect ratio (Letterboxing) */
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            aspect-ratio: 2/1; /* Enforce game shape */
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        /* Responsive Overlay */
        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(15, 12, 41, 0.95);
            backdrop-filter: blur(8px);
            z-index: 20;
            transition: opacity 0.3s;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* Responsive Text Scaling */
        h1 {
            color: #fff;
            font-size: clamp(30px, 5vw, 80px); /* Dynamic font size */
            margin: 0 0 10px 0;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            text-shadow: 0 0 20px #00ff88;
            text-align: center;
        }

        h2 {
            color: #00ff88;
            font-size: clamp(16px, 2.5vw, 30px);
            margin: 0 0 30px 0;
            font-weight: 400;
            text-align: center;
        }

        p {
            color: #aaa;
            font-size: clamp(14px, 2vw, 24px);
            margin-bottom: 30px;
            max-width: 80%;
            text-align: center;
            line-height: 1.5;
        }

        .btn-group {
            display: flex;
            gap: 20px;
        }

        button {
            padding: clamp(10px, 2vw, 15px) clamp(30px, 4vw, 50px);
            font-size: clamp(16px, 2vw, 24px);
            background: transparent;
            color: #00ff88;
            border: 2px solid #00ff88;
            border-radius: 50px;
            cursor: pointer;
            text-transform: uppercase;
            font-weight: bold;
            transition: 0.2s;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
            pointer-events: auto;
            white-space: nowrap;
        }

        button:active {
            transform: scale(0.95);
            background: #00ff88;
            color: #000;
        }

        button:hover {
            background: #00ff88;
            color: #000;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.6);
        }

        button.secondary {
            border-color: #fff;
            color: #fff;
            box-shadow: none;
        }
        
        button.secondary:hover {
            background: #fff;
            color: #000;
            box-shadow: 0 0 20px #fff;
        }

        /* --- HUD --- */
        #hud {
            position: absolute;
            /* HUD sits on top of the canvas area specifically to align with game edges */
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 2/1; /* Match canvas aspect ratio */
            pointer-events: none;
        }

        #scoreBoard {
            position: absolute;
            top: 4%;
            right: 4%;
            text-align: right;
        }

        #scoreVal {
            color: #fff;
            font-size: clamp(24px, 4vw, 40px);
            font-weight: 800;
            text-shadow: 2px 2px 0 #000;
        }

        /* --- Energy Bar --- */
        #energyContainer {
            position: absolute;
            top: 4%;
            left: 4%;
            width: 25%;
            height: 5%;
            background: rgba(0,0,0,0.5);
            border: 2px solid #444;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        #energyFill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff9900, #ffcc00);
            transition: width 0.1s linear;
        }
        
        #energyText {
            position: absolute;
            top: 10%;
            left: 4%;
            color: #666;
            font-size: clamp(10px, 1.5vw, 16px);
            font-weight: bold;
            letter-spacing: 1px;
            text-shadow: 0 0 2px #000;
            transition: color 0.3s;
        }

        /* Skill Button - Made larger for touch */
        #skillButton {
            position: absolute;
            bottom: 5%;
            left: 5%;
            width: clamp(60px, 15vw, 90px);
            height: clamp(60px, 15vw, 90px);
            border-radius: 50%;
            background: rgba(0,0,0,0.6);
            border: 3px solid #444;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            cursor: pointer;
            transition: all 0.2s;
            backdrop-filter: blur(4px);
            -webkit-tap-highlight-color: transparent;
        }

        #skillButton.ready {
            border-color: #ffcc00;
            background: rgba(255, 204, 0, 0.2);
            box-shadow: 0 0 20px #ffcc00;
        }
        
        #skillButton.active {
             background: rgba(255, 255, 255, 0.8);
             border-color: #fff;
             box-shadow: 0 0 40px #fff;
             transform: scale(0.95);
        }

        #skillButton svg {
            fill: #444;
            width: 50%;
            height: 50%;
            transition: fill 0.3s;
        }
        
        #skillButton.ready svg { fill: #ffcc00; }
        #skillButton.active svg { fill: #000; }

        .controls-hint {
            position: absolute;
            bottom: 3%;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.4);
            font-size: clamp(12px, 2vw, 16px);
            letter-spacing: 1px;
        }
        
        /* Stats Table on Start Screen */
        .stats-box {
            background: rgba(255,255,255,0.05);
            padding: 10px 20px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 20px;
            text-align: center;
        }
        .stats-label { font-size: 0.8rem; color: #888; text-transform: uppercase; margin-bottom: 5px;}
        .stats-value { font-size: 1.5rem; color: #fff; font-weight: bold; }
    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    
    <!-- HUD Layer -->
    <div id="hud">
        <div id="scoreBoard">
            <div id="scoreVal">0</div>
        </div>

        <div id="energyContainer">
            <div id="energyFill"></div>
        </div>
        <div id="energyText">CHARGING...</div>

        <div id="skillButton" onmousedown="handleSkillClick(event)" ontouchstart="handleSkillClick(event)">
            <!-- Bolt Icon -->
            <svg viewBox="0 0 24 24">
                <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
            </svg>
        </div>
        
        <div class="controls-hint">TAP to Jump &middot; TAP BOLT for Overdrive</div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="overlay">
        <h1>Cyber Block</h1>
        <h2>Freestyle Block Runner</h2>
        <h3 style="color:#aaa; font-weight:400; margin-bottom:30px;">by Dazzme</h3>
        
        <div class="stats-box">
            <div class="stats-label">High Score</div>
            <div class="stats-value" id="menuHighScore">0</div>
        </div>

        <p>Space/Klik to Jump <br>Shift/Klik Button to Overdrive</p>
        <button onclick="startGame()">START RUN</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="overlay hidden">
        <h1 style="color:#ff0055; text-shadow: 0 0 20px #ff0055;">CRASHED</h1>
        <p>Score: <span id="finalScore" style="color:#fff; font-weight:bold;">0</span></p>
        
        <div class="btn-group">
            <button class="secondary" onclick="backToMenu()">Menu</button>
            <button onclick="startGame()">Retry</button>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('gameContainer');

    // Internal resolution (game logic always thinks it's this size)
    // The CSS scales this up to fit the screen visually.
    const GAME_WIDTH = 800;
    const GAME_HEIGHT = 400;
    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;

    // --- Audio System ---
    const audio = {
        bgm: new Audio('bgm.mp3'),
        jump: new Audio('jump.mp3'),
        overdrive: new Audio('overdrive.mp3'),
        initialized: false
    };

    // Configure Audio Settings
    audio.bgm.loop = true;
    audio.bgm.volume = 0.3; // 30%

    // Browsers cap volume at 1.0. 
    // "150%" requested means max volume, likely pre-amplified or just max.
    audio.jump.volume = 1.0; 
    
    // "130%" requested, capped at 1.0
    audio.overdrive.volume = 1.0; 
    audio.overdrive.loop = true;

    // Function to play sound safely
    function playSound(name) {
        if (!audio.initialized) return;
        
        const s = audio[name];
        if (s) {
            // If it's a one-shot sound like jump, reset it so it can play rapidly
            if (name === 'jump') {
                s.currentTime = 0;
            }
            s.play().catch(e => console.log("Audio play failed: ", e));
        }
    }

    function stopSound(name) {
        const s = audio[name];
        if (s) {
            s.pause();
            s.currentTime = 0;
        }
    }

    // Initialize Audio Context on first user interaction
    function initAudio() {
        if (audio.initialized) return;
        audio.initialized = true;
        // Resume context if needed or just prepare sounds
        // Attempt to play and immediately pause to unlock audio on mobile
        audio.jump.play().then(() => {
            audio.jump.pause();
            audio.jump.currentTime = 0;
        }).catch(() => {});
    }


    // --- Game State ---
    let state = {
        running: false,
        score: 0,
        highScore: 0,
        speed: 6,
        frames: 0,
        shake: 0,
        energy: 0,
        dashing: false,
        gameTime: 0
    };

    // Load High Score safely
    try {
        const savedScore = localStorage.getItem('cyberLeapHigh');
        state.highScore = savedScore ? parseFloat(savedScore) : 0;
    } catch(e) {
        state.highScore = 0;
        console.error("Storage not available");
    }

    document.getElementById('menuHighScore').innerText = Math.floor(state.highScore);

    const player = {
        x: 100,
        y: 200,
        w: 30,
        h: 30,
        vy: 0,
        grounded: false,
        jumpCount: 0,
        color: '#00ff88',
        rotation: 0,
        rotVelocity: 0
    };

    let obstacles = [];
    let particles = [];
    let bgStars = [];
    let bgGridOffset = 0;
    let bgGradientPhase = 0;

    // --- Input ---
    function jump() {
        initAudio(); // Try to init audio on jump input
        if (!state.running) return;
        if (state.dashing) return;

        if (player.grounded) {
            // Jump 1
            player.vy = -13;
            player.grounded = false;
            player.jumpCount = 1;
            player.rotVelocity = 15; 
            createExplosion(player.x + player.w/2, player.y + player.h, 5, '#fff');
            playSound('jump');
        } else if (player.jumpCount < 2) {
            // Jump 2 (Double)
            player.vy = -11;
            player.jumpCount = 2;
            player.rotVelocity = 25; 
            createExplosion(player.x + player.w/2, player.y + player.h, 8, '#00ff88');
            playSound('jump');
            
            // "Freestyle" score bonus
            state.score += 10;
            createFloatingText("+10", player.x, player.y - 20);
        }
    }

    function toggleSkill() {
        initAudio(); // Ensure audio is ready
        if (!state.running) return;

        if (state.dashing) {
            // Deactivate
            state.dashing = false;
            player.rotVelocity = 0;
            player.rotation = 0; // Snap back for safety
            stopSound('overdrive');
            // Resume BGM volume or normal state if weducked it? 
            // Currently overdrive just plays over BGM
        } else {
            // Activate
            if (state.energy >= 20) {
                state.dashing = true;
                state.shake = 5;
                createExplosion(player.x, player.y, 20, '#ffcc00');
                playSound('overdrive');
            }
        }
        updateEnergyUI();
    }

    // Explicit handler for skill button to prevent event bubbling triggering a jump
    function handleSkillClick(e) {
        e.preventDefault();
        e.stopPropagation(); // Stop it from reaching window listeners
        toggleSkill();
    }

    // Keyboard Controls
    window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
            e.preventDefault(); 
            jump();
        }
        if (e.code === 'ShiftLeft' || e.code === 'ShiftRight' || e.key === 'z') {
            toggleSkill();
        }
    });

    // Touch/Mouse Controls (Global for Jump)
    window.addEventListener('mousedown', (e) => {
        // Ignore if clicking a button or the skill button
        if(e.target.closest('button') || e.target.closest('#skillButton')) return;
        e.preventDefault();
        jump();
    });
    
    window.addEventListener('touchstart', (e) => {
        // Ignore if touching a button or the skill button
        if(e.target.closest('button') || e.target.closest('#skillButton')) return;
        e.preventDefault(); // Prevent scroll/zoom
        jump();
    }, {passive: false});

    // --- Core Logic ---

    function init() {
        bgStars = [];
        for(let i=0; i<60; i++) {
            bgStars.push({
                x: Math.random() * GAME_WIDTH,
                y: Math.random() * GAME_HEIGHT,
                size: Math.random() * 2,
                speed: Math.random() * 0.5 + 0.1
            });
        }
        updateEnergyUI();
        document.getElementById('scoreVal').innerText = "0";
    }

    function startGame() {
        initAudio();
        state.running = true;
        state.score = 0;
        state.speed = 7;
        state.frames = 0;
        state.gameTime = 0;
        state.shake = 0;
        state.energy = 0;
        state.dashing = false;
        
        obstacles = [];
        particles = [];
        
        player.y = GAME_HEIGHT - 100;
        player.vy = 0;
        player.rotation = 0;
        player.rotVelocity = 0;
        player.jumpCount = 0;
        player.grounded = false;

        // Start BGM
        playSound('bgm');

        updateEnergyUI();
        document.getElementById('startScreen').classList.add('hidden');
        document.getElementById('gameOverScreen').classList.add('hidden');
        
        requestAnimationFrame(loop);
    }

    function backToMenu() {
        document.getElementById('gameOverScreen').classList.add('hidden');
        document.getElementById('startScreen').classList.remove('hidden');
        document.getElementById('menuHighScore').innerText = Math.floor(state.highScore);
        
        // Reset a bit of background for visual effect
        state.running = false;
        draw(); // Draw static frame
    }

    function gameOver() {
        state.running = false;
        state.shake = 15;
        
        // Stop Audio
        stopSound('bgm');
        stopSound('overdrive');

        if (state.score > state.highScore) {
            state.highScore = state.score;
            try {
                localStorage.setItem('cyberLeapHigh', state.highScore);
            } catch(e) { console.log("Save failed"); }
        }

        document.getElementById('finalScore').innerText = Math.floor(state.score);
        document.getElementById('gameOverScreen').classList.remove('hidden');
    }

    function loop() {
        if (!state.running) {
            if(state.shake > 0) {
                draw();
                state.shake *= 0.8;
                if(state.shake < 0.5) state.shake = 0;
                requestAnimationFrame(loop);
            }
            return;
        }
        update();
        draw();
        requestAnimationFrame(loop);
    }

    function update() {
        state.frames++;
        state.gameTime++;
        
        // Difficulty Ramp
        if (state.frames % 500 === 0) state.speed += 0.5;
        
        // Score Calculation
        state.score += (state.speed / 50);
        document.getElementById('scoreVal').innerText = Math.floor(state.score);
        
        if(state.shake > 0) state.shake *= 0.9;

        // Background Color Shift based on time
        bgGradientPhase = (state.gameTime / 2000) % 1;

        // --- Energy Logic ---
        if (state.dashing) {
            state.energy -= 0.4;
            if (state.energy <= 0) {
                state.energy = 0;
                state.dashing = false;
                player.rotVelocity = 0;
                player.rotation = 0;
                stopSound('overdrive');
            }
            // Overdrive Physics
            player.vy = 0;
            const targetY = GAME_HEIGHT / 2;
            // Smooth lerp
            player.y += (targetY - player.y) * 0.08;
            player.rotation += 25; 
            
            // Add trail
            if (state.frames % 4 === 0) {
                createExplosion(player.x, player.y + player.h/2, 1, '#ffcc00');
            }
        } else {
            // Recharge
            if (state.energy < 100) {
                state.energy += 0.1;
                if (state.energy > 100) state.energy = 100;
            }
            
            // Gravity
            player.vy += 0.6;
            player.y += player.vy;
            player.rotation += player.rotVelocity;

            // Floor Collision
            const floorY = GAME_HEIGHT - 50;
            if (player.y + player.h > floorY) {
                player.y = floorY - player.h;
                player.vy = 0;
                player.grounded = true;
                player.jumpCount = 0;
                
                if (Math.abs(player.rotVelocity) > 5) {
                    createExplosion(player.x + player.w/2, player.y + player.h, 5, '#fff');
                }
                player.rotation = 0;
                player.rotVelocity = 0;
            } else {
                player.grounded = false;
            }
        }
        updateEnergyUI();

        // --- Obstacles ---
        let spawnThreshold = Math.floor(1100 / state.speed); 
        if (spawnThreshold < 50) spawnThreshold = 50;

        if (state.frames % spawnThreshold === 0) {
            spawnObstacle();
        }

        for (let i = obstacles.length - 1; i >= 0; i--) {
            let ob = obstacles[i];
            let moveSpeed = state.dashing ? state.speed * 1.5 : state.speed;
            ob.x -= moveSpeed;

            if (ob.type === 'moving_drone') {
                ob.angle += 0.1;
                ob.y = ob.baseY + Math.sin(ob.angle) * 60;
            }
            if (ob.type === 'saw') {
                ob.rotation += 15;
            }

            // Collision
            const px = player.x + 5;
            const py = player.y + 5;
            const pw = player.w - 10;
            const ph = player.h - 10;

            let collision = false;

            // Simple Box Check
            if (px < ob.x + ob.w && px + pw > ob.x && py < ob.y + ob.h && py + ph > ob.y) {
                collision = true;
            }

            // Saw Precise Check
            if (ob.type === 'saw') {
                collision = false; // Reset to do circle check
                const cx = ob.x + ob.w/2;
                const cy = ob.y + ob.h/2;
                const r = ob.w/2 - 5;
                const pcx = player.x + player.w/2;
                const pcy = player.y + player.h/2;
                // Simple distance check against player center
                const dist = Math.sqrt((cx-pcx)**2 + (cy-pcy)**2);
                if (dist < r + player.w/2) collision = true;
            }

            if (collision) {
                if (state.dashing) {
                    // Smash
                    createExplosion(ob.x + ob.w/2, ob.y + ob.h/2, 12, '#ffcc00');
                    obstacles.splice(i, 1);
                    state.shake = 5;
                    state.score += 50;
                    createFloatingText("SMASH!", player.x, player.y - 30);
                    continue;
                } else {
                    // Platform Logic
                    if (ob.type === 'platform') {
                        const playerBottom = player.y + player.h;
                        // Land on top if falling and near top edge
                        if (playerBottom >= ob.y && playerBottom <= ob.y + 30 && player.vy >= 0) {
                            player.y = ob.y - player.h;
                            player.vy = 0;
                            player.grounded = true;
                            player.jumpCount = 0;
                            player.rotation = 0;
                            player.rotVelocity = 0;
                        } else {
                            gameOver();
                        }
                    } else {
                        gameOver();
                    }
                }
            }

            if (ob.x + ob.w < -100) obstacles.splice(i, 1);
        }

        // Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.02;
            if (p.life <= 0) particles.splice(i, 1);
        }
    }

    function spawnObstacle() {
        const floorY = GAME_HEIGHT - 50;
        const rand = Math.random();
        
        let allowMoving = state.speed > 8;
        let allowSaw = state.speed > 7;

        if (allowMoving && rand > 0.85) {
             obstacles.push({
                x: GAME_WIDTH,
                y: floorY - 100,
                baseY: floorY - 120,
                angle: 0,
                w: 40,
                h: 20,
                type: 'moving_drone'
            });
        } else if (allowSaw && rand > 0.65) {
            obstacles.push({
                x: GAME_WIDTH,
                y: floorY - 50,
                w: 50,
                h: 50,
                rotation: 0,
                type: 'saw'
            });
        } else if (rand > 0.35) {
            let h = Math.random() > 0.5 ? 100 : 180;
            obstacles.push({
                x: GAME_WIDTH,
                y: floorY - h,
                w: 150 + Math.random() * 100,
                h: 20,
                type: 'platform'
            });
        } else {
            obstacles.push({
                x: GAME_WIDTH,
                y: floorY - 40,
                w: 30,
                h: 40,
                type: 'spike'
            });
        }
    }

    function draw() {
        // Dynamic Background
        // Shift hue slightly over time
        let hueShift = Math.floor(bgGradientPhase * 60); 
        let baseColor = `hsl(${240 + hueShift}, 40%, 10%)`;
        let midColor = `hsl(${260 + hueShift}, 40%, 20%)`;
        
        let grad = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
        grad.addColorStop(0, baseColor);
        grad.addColorStop(1, midColor);
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        // Shake
        ctx.save();
        if (state.shake > 0) {
            ctx.translate((Math.random()-0.5)*state.shake, (Math.random()-0.5)*state.shake);
        }

        // Stars
        ctx.fillStyle = '#ffffff';
        bgStars.forEach(star => {
            star.x -= star.speed * (state.dashing ? state.speed : state.speed/3);
            if(star.x < 0) star.x = GAME_WIDTH;
            ctx.globalAlpha = Math.random() * 0.5 + 0.3;
            ctx.fillRect(star.x, star.y, star.size, star.size);
        });
        ctx.globalAlpha = 1.0;

        // Floor
        const floorY = GAME_HEIGHT - 50;
        ctx.fillStyle = '#0f3460';
        ctx.fillRect(0, floorY, GAME_WIDTH, 50);
        
        // Grid
        ctx.strokeStyle = '#e94560';
        ctx.lineWidth = 2;
        ctx.beginPath();
        bgGridOffset -= (state.dashing ? state.speed * 1.5 : state.speed);
        if(bgGridOffset < -50) bgGridOffset += 50;
        for(let x = bgGridOffset; x < GAME_WIDTH; x+=50) {
            if(x < -50) continue; 
            ctx.moveTo(x + 20, floorY);
            ctx.lineTo(x - 20, GAME_HEIGHT);
        }
        ctx.stroke();

        // Obstacles
        obstacles.forEach(ob => {
            ctx.shadowBlur = 0;
            if (ob.type === 'spike') {
                ctx.fillStyle = '#ff0055'; 
                ctx.beginPath();
                ctx.moveTo(ob.x, ob.y + ob.h);
                ctx.lineTo(ob.x + ob.w/2, ob.y);
                ctx.lineTo(ob.x + ob.w, ob.y + ob.h);
                ctx.fill();
            } 
            else if (ob.type === 'moving_drone' || ob.type === 'drone') {
                ctx.fillStyle = '#fc6b03'; 
                ctx.shadowColor = '#fc6b03';
                ctx.shadowBlur = 10;
                ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
                ctx.fillStyle = '#fff';
                ctx.fillRect(ob.x + 5, ob.y + 5, 5, 5);
            } 
            else if (ob.type === 'platform') {
                ctx.fillStyle = '#00aaff'; 
                ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
                ctx.fillStyle = '#fff';
                ctx.fillRect(ob.x, ob.y, ob.w, 3);
            }
            else if (ob.type === 'saw') {
                ctx.save();
                ctx.translate(ob.x + ob.w/2, ob.y + ob.h/2);
                ctx.rotate(ob.rotation * Math.PI / 180);
                ctx.fillStyle = '#bbb';
                ctx.beginPath();
                ctx.arc(0, 0, ob.w/2, 0, Math.PI*2);
                ctx.fill();
                ctx.strokeStyle = '#ff0055';
                ctx.lineWidth = 4;
                ctx.beginPath();
                for(let j=0; j<8; j++) {
                    ctx.rotate(Math.PI/4);
                    ctx.moveTo(ob.w/2, 0);
                    ctx.lineTo(ob.w/2 + 8, 0);
                }
                ctx.stroke();
                ctx.restore();
            }
        });

        // Player
        ctx.save();
        ctx.translate(player.x + player.w/2, player.y + player.h/2);
        ctx.rotate(player.rotation * Math.PI / 180);
        
        let pColor = state.dashing ? '#ffcc00' : player.color;
        let pGlow = state.dashing ? 40 : 20;

        ctx.shadowBlur = pGlow;
        ctx.shadowColor = pColor;
        ctx.fillStyle = pColor;
        ctx.fillRect(-player.w/2, -player.h/2, player.w, player.h);
        
        // Overdrive Shield Effect
        if (state.dashing) {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, player.w, 0, Math.PI*2);
            ctx.stroke();
        }

        ctx.fillStyle = '#000';
        ctx.shadowBlur = 0;
        ctx.fillRect(4, -4, 8, 4);
        
        ctx.restore();

        // Particles & Text
        particles.forEach(p => {
            if (p.text) {
                ctx.fillStyle = "#fff";
                ctx.font = "bold 20px Arial";
                ctx.shadowColor = "#000";
                ctx.shadowBlur = 4;
                ctx.fillText(p.text, p.x, p.y);
                ctx.shadowBlur = 0;
            } else {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.fillRect(p.x, p.y, p.size, p.size);
                ctx.globalAlpha = 1.0;
            }
        });

        // Speed Lines
        if (state.dashing) {
            ctx.strokeStyle = 'rgba(255, 204, 0, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for(let i=0; i<5; i++) {
                let y = Math.random() * GAME_HEIGHT;
                let w = Math.random() * 200 + 100;
                ctx.moveTo(GAME_WIDTH, y);
                ctx.lineTo(GAME_WIDTH - w, y);
            }
            ctx.stroke();
        }

        ctx.restore();
    }

    function createExplosion(x, y, count, color) {
        for(let i=0; i<count; i++) {
            particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                size: Math.random() * 4 + 1,
                life: 1.0,
                color: color
            });
        }
    }

    function createFloatingText(text, x, y) {
        particles.push({
            x: x,
            y: y,
            vx: 0,
            vy: -1,
            life: 1.0,
            text: text
        });
    }

    function updateEnergyUI() {
        const fill = document.getElementById('energyFill');
        const text = document.getElementById('energyText');
        const btn = document.getElementById('skillButton');
        
        fill.style.width = state.energy + '%';
        
        if (state.dashing) {
            fill.style.backgroundColor = '#fff';
            text.innerText = "OVERDRIVE ACTIVE!";
            text.style.color = "#fff";
            btn.classList.add('active');
            btn.classList.remove('ready');
        } else if (state.energy >= 20) {
            text.innerText = "READY [SHIFT]";
            text.style.color = "#ffcc00";
            btn.classList.add('ready');
            btn.classList.remove('active');
        } else {
            text.innerText = "CHARGING...";
            text.style.color = "#666";
            btn.classList.remove('ready');
            btn.classList.remove('active');
        }
    }

    init();
    draw();

</script>
</body>
</html>